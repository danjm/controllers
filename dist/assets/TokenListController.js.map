{"version":3,"file":"TokenListController.js","sourceRoot":"","sources":["../../src/assets/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Patch } from 'immer';\nimport { Mutex } from 'async-mutex';\nimport contractmap from '@metamask/contract-metadata';\nimport { BaseController } from '../BaseControllerV2';\nimport type { RestrictedControllerMessenger } from '../ControllerMessenger';\nimport { safelyExecute } from '../util';\nimport {\n  fetchTokenList,\n  syncTokens,\n  fetchTokenMetadata,\n} from '../apis/token-service';\nimport { NetworkState } from '../network/NetworkController';\nimport { PreferencesState } from '../user/PreferencesController';\n\nconst DEFAULT_INTERVAL = 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 60 * 30 * 1000;\n\nconst name = 'TokenListController';\n\ninterface DataCache {\n  timestamp: number;\n  data: Token[];\n}\ninterface TokensChainsCache {\n  [chainSlug: string]: DataCache;\n}\n\ntype Token = {\n  name: string;\n  address: string;\n  decimals: number;\n  symbol: string;\n  occurrences: number | null;\n  aggregators: string[] | null;\n  iconUrl: string;\n};\n\ntype TokenMap = {\n  [address: string]: Token;\n};\n\nexport type TokenListState = {\n  tokenList: TokenMap;\n  tokensChainsCache: TokensChainsCache;\n};\n\nexport type TokenListStateChange = {\n  type: `${typeof name}:stateChange`;\n  payload: [TokenListState, Patch[]];\n};\n\nexport type GetTokenListState = {\n  type: `${typeof name}:getState`;\n  handler: () => TokenListState;\n};\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n};\n\nconst defaultState: TokenListState = {\n  tokenList: {},\n  tokensChainsCache: {},\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends BaseController<\n  typeof name,\n  TokenListState\n> {\n  private mutex = new Mutex();\n\n  private intervalId?: NodeJS.Timeout;\n\n  private intervalDelay: number;\n\n  private cacheRefreshThreshold: number;\n\n  private chainId: string;\n\n  private useStaticTokenList: boolean;\n\n  /**\n   * Creates a TokenListController instance\n   *\n   * @param options - Constructor options\n   * @param options.interval - The polling interval, in milliseconds\n   * @param options.messenger - A reference to the messaging system\n   * @param options.state - Initial state to set on this controller\n   */\n  constructor({\n    chainId,\n    useStaticTokenList,\n    onNetworkStateChange,\n    onPreferencesStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: string;\n    useStaticTokenList: boolean;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    onPreferencesStateChange: (\n      listener: (preferencesState: PreferencesState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: RestrictedControllerMessenger<\n      typeof name,\n      GetTokenListState,\n      TokenListStateChange,\n      never,\n      never\n    >;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.useStaticTokenList = useStaticTokenList;\n    onNetworkStateChange(async (networkState) => {\n      this.chainId = networkState.provider.chainId;\n      await safelyExecute(() => this.fetchTokenList());\n    });\n    onPreferencesStateChange(async (preferencesState) => {\n      this.useStaticTokenList = preferencesState.useStaticTokenList;\n      await safelyExecute(() => this.fetchTokenList());\n    });\n  }\n\n  /**\n   * Start polling for the token list\n   */\n  async start() {\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list\n   */\n  async fetchTokenList(): Promise<void> {\n    if (this.useStaticTokenList) {\n      await this.fetchFromStaticTokenList();\n    } else {\n      await this.fetchFromDynamicTokenList();\n    }\n  }\n\n  /**\n   * Fetching token list from the contract-metadata as a fallback\n   */\n  async fetchFromStaticTokenList(): Promise<void> {\n    const tokenList: TokenMap = {};\n    for (const tokenAddress in contractmap) {\n      const { erc20, logo, ...token } = contractmap[tokenAddress];\n      if (erc20) {\n        tokenList[tokenAddress] = { ...token, iconUrl: logo };\n      }\n    }\n    this.update(() => {\n      return {\n        tokenList,\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Fetching token list from the Token Service API\n   */\n  async fetchFromDynamicTokenList(): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const tokensFromAPI: Token[] = await safelyExecute(() =>\n        this.fetchFromCache(),\n      );\n      const { tokensChainsCache } = this.state;\n      const tokenList: TokenMap = {};\n\n      // filtering out tokens with less than 2 occurences\n      const filteredTokenList = tokensFromAPI.filter(\n        (token) => token.occurrences && token.occurrences >= 2,\n      );\n      // removing the tokens with symbol conflicts\n      const symbolsList = filteredTokenList.map((token) => token.symbol);\n      const duplicateSymbols = [\n        ...new Set(\n          symbolsList.filter(\n            (symbol, index) => symbolsList.indexOf(symbol) !== index,\n          ),\n        ),\n      ];\n      const uniqueTokenList = filteredTokenList.filter(\n        (token) => !duplicateSymbols.includes(token.symbol),\n      );\n      for (const token of uniqueTokenList) {\n        tokenList[token.address] = token;\n      }\n      this.update(() => {\n        return {\n          tokenList,\n          tokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   *  if yes data in cache will be returned\n   *  otherwise a call to the API service will be made.\n   * @returns Promise that resolves into a TokenList\n   */\n  async fetchFromCache(): Promise<Token[]> {\n    const { tokensChainsCache, ...tokensData }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[this.chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    const tokenList: Token[] = await safelyExecute(() =>\n      fetchTokenList(this.chainId),\n    );\n    const updatedTokensChainsCache = {\n      ...tokensChainsCache,\n      [this.chainId]: {\n        timestamp: Date.now(),\n        data: tokenList,\n      },\n    };\n    this.update(() => {\n      return {\n        ...tokensData,\n        tokensChainsCache: updatedTokensChainsCache,\n      };\n    });\n    return tokenList;\n  }\n\n  /**\n   * Calls the API to sync the tokens in the token service\n   */\n  async syncTokens(): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      await safelyExecute(() => syncTokens(this.chainId));\n      const { tokenList, tokensChainsCache } = this.state;\n      const updatedTokensChainsCache = {\n        ...tokensChainsCache,\n        [this.chainId]: {\n          timestamp: 0,\n          data: [],\n        },\n      };\n      this.update(() => {\n        return {\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Fetch metadata for a token whose address is send to the API\n   * @param tokenAddress\n   * @returns Promise that resolvesto Token Metadata\n   */\n  async fetchTokenMetadata(tokenAddress: string): Promise<Token> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const token = await safelyExecute(() =>\n        fetchTokenMetadata(this.chainId, tokenAddress),\n      );\n      return token;\n    } finally {\n      releaseLock();\n    }\n  }\n}\n\nexport default TokenListController;\n"]}